散列技术是在记录的存储位置和它的关键字之间建立一个确定的对应关系f，
使得每个关键字key对应一个存储位置f(key)。这里的对应关系f称为散列函
数或哈希（Hash）函数。采用散列技术将记录存储在一块连续的存储空间中，
这块连续存储空间称为散列表或哈希表（Hash Table）。

设计一个简单、均匀、存储利用率高的散列函数是散列技术中的最关键的问
题。另一个问题就是冲突（collision）。两个关键字key1 != key2，但是却
有f(key1) == f(key2)，这种现象称为冲突，并把key1和key2称为这个散列
函数的同义词。如何避免冲突也是一个很重要的课题。

好的散列函数设计原则：
1.计算简单
2.散列地址分布均匀 -- 这样也可以解决冲突的问题和存储空间利用率的问题

常见的散列方法：
1.直接定址法：f(key) = a * key + b，其中a、b是常数，这种方法简单、均
  匀，也不会冲突，但是需要事先直到关键字的分布情况，适合查找表小且连
  续的情况。
2.数字分析法：对关键字进行分析、抽取，直接利用抽取的部分或者对该部分
  进行简单的处理从而形成散列函数。数字分析法适合关键字位数比较大的情
  况，如果事先直到该关键字的分布且关键字的若干位分布均匀，就可以考虑
  使用该方法。如手机号--抽取。
3.平方取中法：比如对关键字1234计算平方，然后取中间的一部分，适合不知
  道关键字的分布，而位数又不是很大的情况。
4.折叠法：将关键字从左到右分割成位数相等的几部分（最后一部分不足时可
  以补齐或者短一些），然后将这几部分叠加求和，并按散列表表长，取后几
  位作为散列地址。适合不知道关键字的分布，且关键字位数比较大的情况。
5.除留余数法：f(key) = key mode p (p <= m)，其中m是散列表的长度，本方
  法的关键是如何选择p，p选的不好就容易造成同义词。经验表明：若散列表
  长度为m，通常p为小于或等于表长m（最好接近m）的最小质数或不包含小于
  20质因子的合数 -- 最常用
6.随机数法：f(key) = random(key)，random是随机函数。当关键字长度不等
  时比较适合此方法。
如果关键字是字符串，其实各种字符都可以转换成数字的，如ASCII码或Unicode
码等，从而转换成上面的方法。

影响散列函数设计的常见因素：
1.计算散列地址的时间
2.关键字的长度
3.散列表的长度
4.关键字的分布情况
5.记录查找的频率

散列冲突的处理方法：
1.开放定址法：又称线性探测法，公式：f(key) = (f(key) + d) mode m，其
  中d的取值为(1, 2, 3, ..., m-1)，即如果冲突了就去找下一个位置，只要
  散列表长度够，就会找到一个存储位置，但是会引入堆积的问题，堆积：本
  来不是同义词却需要争夺一个地址的情况（因为冲突，这解决冲突时被冲突
  的关键字占用了该位置，而该位置在后续的构建过程中是有实际的关键字对
  应的，此关键字和冲突解决中的关键字不是同义词），堆积的出现使我们不
  断的解决冲突，无论是插入还是查找的性能都会大大降低。针对这个问题，
  又提出了二次探测法：增加平方运算，目的是为了不让关键字都聚集在某一
  个区域，减少冲突，公式：f1(key) = (f(key) + di) mod m，其中di的取值
  为：1², -1², 2², -2², 3², -3², ..., q², -q², q<=m/2，增加负数这样可
  以从两个方向进行探测，提升效率。此外还有一种随机探测，对于位移量di
  采用随机数计算得到，称为随机探测法（这里的随机是一种伪随机，相同的
  种子可以得到相同的随机数）。
2.再散列函数法：设置一组散列函数，每个散列函数使用的方法都不一样，这
  样当使用一个散列函数产生冲突时，继续使用下一个散列函数。这种方法会
  增加计算量。
3.链式地址法：将所有关键字为同义词的记录都存储在一个单链表中，称为同
  义词子表，在散列表中只存储所有同义词子表的头指针，此时无论产生多少
  冲突都是在当前位置给单链表增加节点的问题（一般都是在表头增加节点）
4.公共溢出法：建立一个单独的溢出表，所有冲突的关键字的记录都存储到溢
  出表，查找时先查找基本表，如果不存在则去溢出表进行顺序查找。

散列平均性能影响因素：
1.散列函数是否均匀
2.处理冲突的方法
3.散列表的装填因子：ac = 表中的记录数/散列表的长度，记录数越多，装填
  因子就越大，产生冲突的概率就越大。也就是说，散列表的平均查找长度取
  决于装填因子，而不是取决于查找集合中的记录个数。一般都是浪费一定的
  空间。redis中会通过此装填因子进行rehash。
